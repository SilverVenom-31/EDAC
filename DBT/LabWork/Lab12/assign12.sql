use humanresource;

delimiter //
drop procedure if exists user_query_emp //
create procedure user_query_emp (p_myeno int , out p_myjob varchar(20),out p_mysal int )
begin
declare count int ;
select count(*) into count from employees where employee_id = p_myeno;

if p_myeno is null
then 
	select 'Please do not enter null value' as message;
elseif count > 0 then
select job_id,salary into p_myjob,p_mysal from employees where employee_id = p_myeno;
else select 'employee id does not exists' as message;
end if;

end //
delimiter ;


call user_query_emp(100,@x,@y);

-- ===============================================================================================================

    
    delimiter //
    drop function if exists user_annual_comp //
    create function user_annual_comp(p_sal int,p_comm int) returns int
    begin
	declare annual_compensation int;
	if p_sal is null then
		set p_sal = 0;
	elseif p_comm is null then
		set p_comm =0;

	 end if;
	 
	set  annual_compensation = (p_sal+p_comm)*12;
	 
	 
	 return annual_compensation;
    
    end //
    delimiter ;
    
    
    -- ===========================================================================================================
    
        • Create a function named USER_VALID_DEPTNO that has a single parameter p_dno to accept a department number and returns a BOOLEAN value. The function returns TRUE if the department number exists in the DEPT table else it returns FALSE.
    • Create a procedure named SHOW_STRENGTH that accepts department number in a single parameter p_deptno from user. The procedure gives a call to USER_VALID_DEPTNO. If the function returns TRUE then the procedure finds out how many employees are there in the department from the EMP table and displays the same on the screen. If the function returns FALSE then the procedure displays an appropriate error message.
    • Give call to SHOW_STRENGTH by passing on department number 10. Do the same for department number 76
    
    
    delimiter //
    drop function if exists user_valid_deptno //
    create function user_valid_deptno (p_dno int) returns boolean
    begin
    declare count int;
    
    select count(*) into count from departments where department_id = p_dno;
    
    if count>0 then
    return true;
    else return false;
    end if;
    
    
    end //
    delimiter ;

-- ----------------
	
	delimiter //
	drop procedure if exists show_strength //
	create procedure show_strength(p_deptno int)
	begin
    
	if user_valid_deptno(p_deptno) then
	select count(*) as NumberOfEmployees from employees where department_id = p_deptno;
	else 
	 select 'department_id does not exists' as message;
	end if;
	end //
	delimiter ;


-- =======================================================================================================================================


    • Create a procedure named ADD_EMPLOYEE to hire an employee. Parameters to the procedure are job, mgr, hiredate, salary, commission and deptno. Validate the following:

a. Employee number is not taken as a parameter but is auto generated by using a SEQUENCE. 
b. Job is either ‘CLERK’ or ‘ANALYST’ or ‘SALESMAN’. The input value can be entered in any case (upper or lower or initcap). --
c. Mgr is an existing employee. --
d. Hiredate is less than system date. --
e. Salary must be greater than 800 --
f. Commission is not null if the job is SALESMAN. For any other job, commission is null. --
g. Deptno must exist in the DEPT table. 
Insert the record if the above validations are met and display a message ‘1 row inserted’. If the row is not inserted generate an exception and handle it by displaying an appropriate message. 
    • Give a call to ADD_EMPLOYEE through an anonymous PL/SQL block
    
    -- -------------
    
    delimiter //
    drop procedure if exists add_employee_initial //
    create procedure add_employee_initial (jobid varchar(20),mgr int,hiredate date,sal int ,comm float ,deptid int , out status boolean)
    level : begin
    declare count,datediff,dept int;
    select count(*) into count from emp_bk where employee_id = mgr;
    select count(*) into dept from departments where department_id = deptid;
	select datediff(curdate(), hiredate) into datediff;
    set status = true;
    if ((jobid like '%CLERK') or (jobid like 'SA%') or(jobid like '%ANALYST%') ) then
		if status=false then
			set status =true;
		end if;
    else select 'Please enter job: clerk or salesman or analyst only' as error_message;
		set status = false;
		leave level;
    end if;
    
    if count>0 then
    	if status=false then
			set status =true;
		end if;
	else
    	select 'Employee does not exists' as error_message;
         set status = false;
         leave level;
    	end if;
    	

	if datediff > 0 then
		if status=false then
			set status =true;
		end if;
    else select 'Invalid date: More than system date' as error_message;
		set status = false;
		leave level;
	end if;
    
    if sal > 800 then
    	if status=false then
			set status =true;
		end if;
	else select 'salary less than 800' as error_message;
		set status = false;
		leave level;
	end if;
    	
	if (comm is null) and (jobid like 'SA%') then
    	select 'Commission should not be null in job of salesman' as error_message;
		set status = false;
		leave level;
	else 
    	if status=false then
			set status =true;
		end if;
	end if;
    	
	if dept > 0 then
		if status=false then
			set status =true;
		end if;
    else select 'department id should be of department table' as error_message;
		set status = false;
		leave level;
	end if;
    	
	if status then
        insert into emp_bk (job_id,department_id,commission_pct,salary,hire_date,manager_id) 
					values (upper(job_id),deptid,comm,sal,hiredate,mgr);
	else 
        set status = false;
	end if ;
  
    end //
    delimiter ;

-- ---------------------
DELIMITER // drop procedure if exists ADD_EMPLOYEE //
create procedure ADD_EMPLOYEE (JOBID varchar(20), MGR int, HIREDATE date, SAL int , COMM float , DEPTID int) 
begin
    call ADD_EMPLOYEE_INITIAL(JOBID , MGR , HIREDATE , SAL , COMM , DEPTID, @STATUS);
if (@STATUS) 
then
    select
        'employee record added successfully' as MESSAGE;
else
    select
        'employee record adding failed' as ERROR_MESSAGE;
end
if;
end
// DELIMITER ;

-- call add_employee('SA_mgr' ,800 ,'2020-11-10' ,200 ,null  ,700);

-- =============================================================================================================


Practice 1

    • Implement the following business rule with the help of a trigger named TR_CHECK_DEPT and a procedure named SECURE_DML. Changes to data in the dept table, will be allowed only in the month of March.
    • Create a procedure called SECURE_DML that prevents the DML statement from executing in any other
    month than March.  In case, a user tries to modify the table in any other month, the procedure should
    display a message “You can modify or add a department only at the end of a financial year”
    • Create a statement level triggerTR_CHECK_DEPT on the dept table that calls the above procedure.
    • Test it by inserting a new record in the dept table.



delimiter //
drop trigger if exists TR_CHECK_DEPT1 //
create trigger TR_CHECK_DEPT1 
before 
update on dept_bk for each row
begin

call SECURE_DML();

end //
delimiter ;
 -- --------
 delimiter //
drop trigger if exists TR_CHECK_DEPT2//
create trigger TR_CHECK_DEPT2 
before 
update on dept_bk for each row
begin

call SECURE_DML();

end //
delimiter ;


-- ------------


delimiter //
drop procedure if exists SECURE_DML //
create procedure SECURE_DML()
begin
declare passMonth int default 3;
declare checkMonth int;
select month(curdate()) into checkMonth;

if (checkMonth != passMonth) then
SIGNAL SQLSTATE '45000'
SET MESSAGE_TEXT = 'You can modify or add a department only at the end of a financial year';

end if;
end //
delimiter ;

-- ===============================================================================================
Practice 2

    • Enforce referential integrity with a trigger named TR_CASCADE_CHANGE.
    When the value of DEPTNO changes in the Dept table, cascade the update to the corresponding 
    rows in the EMP table. 
    • Test it by updating the value of a deptno from the dept table.
  
  delimiter //
  drop trigger if exists TR_CASCADE_CHANGE //
  create trigger TR_CASCADE_CHANGE
  after update
  on departments for each row 
  begin
  
  if old.department_id != new.department_id then
  update employees set department_id = new.department_id where department_id = old.department_id;
  end if;

  end //
  delimiter ;
  
  -- ==========================================================================================
  
  
  
  Practice 3

    • Create a trigger named TR_CHECK_COMM to implement the following business rule. In EMP table, employee 
    having job as ‘Salesman’ should receive a commission. A Salesman must receive a commission of not less than 
    Rs. 100. Employees who are not sales persons are not entitled to get commission (comm value should be NULL).
    • Test it by inserting a record in the emp table.
  
  
  
  
  
  
  delimiter //
  drop trigger if exists TR_CHECK_COMM //
  create trigger TR_CHECK_COMM
  before insert on emp_bk for each row
  begin
  declare commCheck float; 
  
  if new.job_id like 'SA_%' then
  
	if new.commission_pct is null then
		signal sqlstate '55000'
		set message_text = 'commissiion_pct cannot be null for salesman';
        else 
			set commCheck = new.commission_pct * new.salary;
            if commCheck < 100 then
				signal sqlstate '56000'
				set message_text = 'commissiion_pct should be greater than 100';
            end if;
			
	end if;
  else 
	if new.commission_pct is not null then
		signal sqlstate '57000'
		set message_text = 'commissiion_pct be null for employees other than salesman';
	end if;
  end if;
  
  end //
  delimiter ;
  
  
  
  
  








