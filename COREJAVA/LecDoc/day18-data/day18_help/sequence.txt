Revise Hashing algorithm
If you want to add any elements to hashing based Data Structure (HS, LHS , HM LHM, Hashtable)
Which methods need to be overridden ?
equals n hashCode

Object class API
public boolean equals(Object o) : rets true iff : both the refs (invoker n arg) are referring to the SAME object, otherwise rets false.(ref equality)

public int hashCode() : internal representation of address

What's the need to override them ?
To obey the contract.

Contract : Equal objects MUST produce SAME hash code. : Mandatory
Un equal objects SHOULD produce distinct hash codes : optional BUT reco for ensuring constant time performance.

HOW ?
1. Identify PK (unique identity) data memeber/s, override equals method
2. Using SAME data members , override hashCode
(Help : String, Wrappers, Date related classes : have alrdy imple the contract)



LinkedHashSet : extends HashSet (hashCode n equals)
un sorted BUT ordered set.
eg : List<String> l1=Arrays.asList("xyz","abc","pqr","sdfg","abc");
//l1.add("sdfgf");
LinkedHashSet<String> strings=new LinkedHashSet <>(l1);
sop(strings);//[xyz","abc","pqr","sdfg"]
sop(strings.size());//4
strings.add("43524");//no err


TreeSet<Emp> : un -ordered , sorted
1. TreeSet() : Empty , 
when u add the elems : Emp's compareTo

2. TreeSet(Collection<E> coll) : populated set.
During this constr invocation : Emp's compareTo


3. TreeSet(Comparator<E> comp) : Custom ordering
eg : TreeSet<Emp> ts=new TreeSet<>(new Comparator<Emp>()
{
  //which method to imple ? : 
 @Override
  public int compare(Emp e1, Emp e2) {....}

}); //empty set
sop(ts);//[]
//methods : add /addAll...
when u add the elems : ano inner's compare
-------------------------------------------
More about generic syntax : ? , extends ,super
eg : 
Inheritance hierarchy : Emp <---Mgr <----HRMgr
Emp <--- Worker <--- TempWorker
1. public ArrayList(Collection<? extends E> c)
eg : ArrayList<Emp> emps=new AL<>(Any Set/List <Emp or it's sub type)

E : Emp 
This constr can create populated AL<Emp> :  from ANY Collection(AL/LL/Vector : YES
HS/LHS/TS :  YES 
HM/LHM/TM : NO) with generic type of Emp or its sub type(eg : any worker or any mgr)


AL<Emp> : to be populated



Generic syntax :
? : wild card in generic syntax (it can be replaced by ANY type) : un bounded wild card
extends : Represents upper bound
super : Represents lower bound
? extends E : ANY type E or its sub type (E : Emp)
? super E : E or its super type

What will happen ? (javac error or no error?)
1. Vector<Mgr> mgrs=new Vector<>();
mgs.add(m1)....m10
ArrayList<Emp> emps=new AL<>(mgrs);//no err

2. HashSet<HRMgr> hrMgrs=new HS<>();
hrMgrs.add(hrm1)....hrm10
ArrayList<Emp> emps=new AL<>(hrMgrs);//no err
3.
ArrayList<Mgr> mgrs=new AL<>();//no err
mgrs.add(m1).....m10
LinkedList<HRMgr> hrMgrs=new LinkedList<>(mgrs);//err : LinkedList IS A Collection ,
YOu can create a populated LinkedList<HRMgr> from : ANY Collection of generic type : HRMgr or it's sub type . Since Mgr IS NOT a HR MGR : javac err

Ans this !
ArrayList<Mgr> mgrs=new AL<>();
mgrs.add(m1).....m10
ArrayList<? extends Emp> emp=new AL<>(mgrs);//no error
ArrayList<? extends Object> objs=new AL<>(mgrs);//no error



3.Collections class(Non generic class) :  Can contain a generic Method
eg : super keyword in generics : lower bound
Method of Collections class
public static <T> void sort(List<T> list,Comparator<? super T> c)
generic method : 
where does type declaration fit ? : It's placed between method modifiers n ret type
1st arg : List<T> list : You can pass List of ANY type (eg : AL/LL/Vector : YES
HS/LHS/TS : NO
HM/LHM/TM : NO) : 
Can you pass List of the following types :  
T --Customer , Student(extends Person) , BankAccount,Flight, Movie,Person , DacStudent (extends Student)
if above classes have not imple Comparable or Comparator : No problem!

2nd arg : Comparator<? super T> c
Instance of the class which imple Comparator
eg : Collections.sort(studentList,comp);//comp : imple Comparator<Student> : no err
 Collections.sort(studentList,comp);//comp : imple Comaprator<Fruit> : err
Collections.sort(studentList,comp);//comp : imple Comaprator<Person> : no err
Collections.sort(studentList,comp);//comp : imple Comaprator<Object> :  no err
Collections.sort(studentList,comp);//comp : imple Comaprator<eDacStudent> : javac err
------------------------------

Enter Maps
Map<K,V> interface n it's implementation classes


Objectives : 
Store bank account details in a suitable map.(it ensures constant time performance)
PK : acct number (int)
HashMap<Integer,BankAccount> : hashing algorithm (hashCode n equals)
Key class MUST satisfy the constract : Integer : It has already followed the contract.

Another Business scenario
If Unique ID(PK)  : acct Number (int) & IFSC (string) then how ?
You have to create a custom key class
eg : public class AccountPk
{
//D.M : acct Number (int) & IFSC (string)
//mandatory : hashCode n equals as per contract
}
HashMap<AccountPk,BankAccount>



0. Create new empy map to store bank account details
HashMap<Integer,BankAccount>  hm=new HM<>();

0.5 Create new account
Map i/f API
1. public V put(K key,V value)
Meaning : It will insert the new entry into map.If key already exists : it will replace old value by new value.
Rets : null in case of new entry or old value ref. in case of existing entry.
eg : 
HM<K,V> hm=new HM<>();//empty
sop(map.put(k1,v1));//null
sop(map.put(k2,v2));//null
sop(map.put(k3,v3));//null
sop(map.put(k1,v4));//rets v1
//which entries   :  {k1:v4, k2:v2,k3:v3}
2. public  V putIfAbsent(K key,V value)
eg : sop(map.putIfAbsent(k1,v1));//null
sop(map.putIfAbsent(k2,v2));//null
sop(map.putIfAbsent(k3,v3));//null
sop(map.putIfAbsent(k1,v4));//v1
//which values(entries)  :  k1:v1 k2:v2 k3:v3
3. public void putAll(Map<? extends K,? extends V> m)
eg : map1.putAll(map2);
Meaning : It will copy all entries from map2 ----> map1
(put : replace)
eg : HashMap<Integer,BankAccount> accts=new HM<>(????????)
???? => Any Map impl class (HM/LHM/TM...)  of the generic type
K : Integer or it's sub class
V : BankAccount or it's sub class

4. public V get(Object key)
Rets value type of ref if key is found else rets null.
eg : HM : {k1:v1, k2,v2 , k3:v3}
map.get(k2) : v2
map.get(k10) : null

5. boolean containsKey(Object key)
Returns true if this map contains a mapping for the specified key , otherwise false;
eg : map.containsKey(k1) ---true

6. boolean containsValue(Object value)
Returns true if this map maps one or more keys to the specified value. 
eg : map :  k1:v1 k2:v2 k3:v3
map.containsValue(v3) ---- true

containsKey : O(1)
containsValue : O(n)

7. public V remove(Object K)
Tries to remove the entry(=mapping=key n value pair) if key is found --rets existing value ref.
Rets null if key is not found.;
eg : map :  k1:v1 k2:v2 k3:v3
sop(map.remove(k2));//v2
sop(map);//k1:v1  k3:v3
sop(map.remove(k20));//null
sop(map);//k1:v1  k3:v3

0. Create new empy map to store bank account details
HashMap<Integer,BankAccount>  hm=new HM<>();

0.5 Create new account
put/putIfAbsent

1. Display  details of all accounts : toString

2. 
get acct summary --- i/p --acct number 
o/p --- error via custom exception OR  account details

3. Funds Transfer 
i/p src acct no , dest acct no , transfer amount

4.Close account
i/p id 


5.Apply interest on on saving type of a/cs.


How to overcome limitations of Map (can't iterate over map , can't search/sort/remove by any value based criteria)
Solution : Convert the map into its Collection view
1. How to extract key type refs from a Map ?
public Set<K> keySet()
eg : HM<Integer,BankAccount> hm=new HM<>();
added some a/cs 
  Set<Integer> keys =hm.keySet();//O(n)

2. How to get value type of references from a Map ?
public Collection<V> values();
eg : HM<Integer,BankAccount> hm=new HM<>();
added some a/cs ....
Collection<BankAccount> accts =hm.values();//O(n)

3. How to get key-value pair(entry) of references from a Map ?
Map : i/f 
Nested i/f : Map.Entry<K,V> : Entry in a Map
public Set<Map.Entry<K,V>> entrySet();

4. Method of Map.Entry i/f
public K getKey()
public V getValue();






