Scheduling Algorithm examples
=============================
Non-preemptive examples:
1. FCFS : First come First Serve
2. SJF : Shortest Job First
3. Priority Scheduling : Scheduled based on priority

Preemptive examples:
1. Round Robin
2. Shortest Remaining Time First

FIFO - First come first served
1. FIFO is non pre-emptive
2. The context switch happens only on process termination
3. No Starvation observed

Shortest Job First
1. Non preemptive algorithm
2. Total execution time must be known before execution
3. Starvation can be observed

Priority Scheduling
1. Dynamic priority Scheduling algorithm
2. Used in Real time O.S
3. Queue will be searched for the process closest to its deadline.

Round Robin
1. Preemptive algorithm
2. Employs Time-sharing algorithm
3. Gives each job its time-slice a.k.a quantum.

Shortest Remaining Time First
1. Preemptive algorithm
2. Preemptive version of Shortest Job First Algorithm
3. The process with least remaining time is executed first.

Thread
======
A thread of execution is often regarded as the smallest unit of processing that a scheduler works on.
A thread is also called a lightweight process
Threads enable true parallelism on multiple processor machines

Threads are created like normal tasks, with the exception that the clone() system call is passed flags corresponding to specific resources to be shared:

clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);

Meaning of above Flags with clone()

CLONE_VM	Parent and child share address space.
CLONE_FS	Parent and child share filesystem information.
CLONE_FILES	Parent and child share open files.
CLONE_SIGHAND	Parent and child share signal handlers and blocked signals.

Note: Linux has support for hundreds to thousands of threads.

Process vs Thread
=================
Process is heavy weight or resource intensive.	
Thread is light weight, taking lesser resources than a process.

Process switching needs interaction with operating system.	
Thread switching does not need to interact with operating system.

In multiple processing environments, each process executes the same code but has its own memory and file resources.	
All threads can share same set of open files, child processes.

If one process is blocked, then no other process can execute until the first process is unblocked.	
While one thread is blocked and waiting, a second thread in the same task can run.

Multiple processes without using threads use more resources.	
Multiple threaded processes use fewer resources.

In multiple processes each process operates independently of the others.
One thread can read, write or change another thread's data.

Advantages of Thread
====================
Threads minimize the context switching time.
Efficient communication.
It is more economical to create and context switch threads.
Threads allow utilization of multiprocessor architectures

How Linux OS treats threads
===========================
Linux has a unique implementation of threads.  To the Linux kernel, there is no concept of a thread. 
Linux implements all threads as standard processes. 
The Linux kernel does not provide any special scheduling semantics or data structures to represent threads. Instead, a thread is merely a process that shares certain resources with other processes.
Each thread has a unique task_struct and appears to the kernel as a normal process 

Kernel Level Threads
====================
Kernel threads are processes that exist only in kernel space.
Kernel threads can only be created by other kernel threads

LifeCycle

You can create a kernel thread with the kthread_create() function. The thread will be created in an no-running state.You can create and start a kernel thread with kthread_run(). Once started a kernel thread continues to exist until either it calls do_exit() or another thread calls kthread_stop()


Show threads per process

We can count threads with the list of available sub directories inside /proc/<PID>/task/
For example to check some thread count --> ls /proc/$(pidof process)/task/



----
Running c program via Shell
=================================
You would need the compiler - gcc

gcc --version

yum -y install gcc (Centos)
apt-get install gcc (Ubuntu)

==================================
nano hello.c

#include <stdio.h>

int main()
{
  printf("hello world\n");
  return 0;
}

Compile
gcc hello.c -o hello

To execute program:
./hello
===================================





